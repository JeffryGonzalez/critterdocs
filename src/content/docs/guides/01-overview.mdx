---

title: Overview 
---


import { Steps } from '@astrojs/starlight/components';


We are going to start our exploration of using the Critter Stack for building an application backend by resetting your thinking about application development a bit.


If you are like me, you come from a long line of thinking and architectural patterns that have become sort of the *ideology* of software development. What I mean is that there is a certain way things are done, or rather, a certain way you do things, and you don't even think about it.

The more experience you have, it seems, the harder it is to both notice these stances, and to break from them.

For example, I remember buying a book about HTTP API design a few years ago and the first page said something like:

> The best way to design a great API is to start with a good database

The internet and the software development community is full of these kinds of statements. They are often presented as *truths* or *axioms* that you should just accept and move on. We think about the database first, maybe too much.

But what if I told you that the database is not the most important part of your application? What if I told you that the database is just a tool, and that the real value of your application comes from the business logic and the user experience?

The **Critter Stack** is a new way of thinking about application development. It is a way of thinking that puts the user experience and the business logic at the center of your application, and uses the database as a tool to support that.

## Creating Our Vocabulary

If we are going to change the way we think about application development, we need to create a new vocabulary. We need to create a new way of talking about the things we do every day.

We build applications to provide some kind of *value* for our users, and, therefore, the company that is paying us to build it. Our application, at a high-level, *does things*, and "business" cares about those things, because they impact the bottom line, or 
expose potential new revenue streams or even liabilities to be avoided.

We also have *technical* things that we care about. We care about how we build our applications, and how we deploy them. We care about how we test them, and how we monitor them. We care about how we scale them, and how we secure them. There are things that happen *behind the scenes* 
that we, as software developers, care about, but aren't so much "business facing".

In the world when "things happen", there is a common term that is used. An *event*. An Event is something that happens, and it is always associated with a point on a timeline. 

An event is something that happens at a specific time, and it can be used to trigger other things to happen. An event can be something that happens in the real world, or it can be something that happens in the digital world. An event can be something that happens to a user, or it can be something that happens to a system. An event can be something that happens to a database, or it can be something that happens to an application. An event can be something that happens to a server, or it can be something that happens to a client. An event can be something that happens to a network, or it can be something that happens to a device.

When we build an application, we are *always* building something that responds to a fixed-set of events. An application that is running on a timer (like a CRON job), is responding to a timer event. 
An application that is running in response to a user clicking a button is responding to a user event. 
An application that is running in response to a network request is responding to a network event.

For example, an HTTP API responds to HTTP Request Events. It has *nothing to do* until an event it is expecting comes knocking at the TCP door. A user interface is, on these terms, a way to provide events for our system to handle.

### Events

In the Critter Stack, and event is nothing really special. It's just an object created that optionally has some data attached to it to give it some details.

```cs title="Sample Event"
public record UserCreated();
```

Events are grouped together into a stream of related things. That *stream* gives some context to the event. As you will see, any of our code will have access to these events, if we need to read them, or do some processing on them. Don't think of streams as a "private world", more like a context for a group of 
related events. Some of these you may know when you start building your system, some you will discover later on. 

:::note 
Don't get too hung up on the code examples yet, these aren't meant to be runnable code. We'll get to that soon enough
:::

<Steps>

1. User Is Created

    ```csharp
    var created = new UserCreated();
    ```

2. User Sets Password

    ```csharp
    var passwordSet = new UserSetPassword("TacoSalad123!");
    ```

3. User Sets their UserName
    
    ```csharp
    var userNameSet = new UserSetName("paulo");
    ```

</Steps>

Now, these kind of things will typically happen over a span of time. But for discussions sake, let's say we are doing them all in sequence like this:

```csharp
var created = new UserCreated();
var passwordSet = new UserSetPassword("TacoSalad123!");
var userNameSet = new UserSetName("paulo");

// create a uuid for this user to create some context for all these events.
var userStreamId = Guid.NewGuid(); 

session.Events.StartStream(userStreamId, created, passwordSet, userNameSet);
await session.SaveChangesAsync();

```

These events will all be *logged* in a durable way. We have a record of everything (so far) that's happened to the user with the stream of `userStreamId`.

*Conceptually*, you can imagine a log file that looks like this:

| StreamId | Timestamp | Event |
|----------|---|----|
| 123 | 1742402102000 | User Created |
| 123 | 1742402102001 | UserSetPassword ("TacoSalad123!")|
| 123 | 1742402102002 | UserSet Name ("paulo") |

We *could* (and we'll see how, later) query the "raw" events to see what is going on with that particular user. 

That would be a bit challenging to do, but we could do it.

But, we can also use these events to build a *projection* of the user. A projection is a way to take the raw events and turn them into something that is more useful for us.

The Critter Stack has a built-in way to query a stream of events to derive some information - really any information - we might want about that particular user. 

So let's say we just wanted to be able to ask "what is the user name for this user, and have they set their password yet?".

If I were to sketch that out as a C# class, it might look something like this:

```csharp
public class UserInfoReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public bool HasSetPassword { get; set; }
}
```

That's what I'd want to get back from looking at the stream of events for this particular user. All we have to do is give the Critter Stack a way to *project* the events into this class, and what the events (we are interested in), mean to this particular class.


It's pretty simple. I want to tell it that when it sees a `UserCreated` event, it should set the `Id` property to the stream id. When it sees a `UserSetName` event, it should set the `Name` property to the name in the event. And when it sees a `UserSetPassword` event, it should set the `HasSetPassword` property to true.

The CritterStack prefers to let us lean into what we already know as C# developers, and does it's best to stay out of the way. 

So, I could say one of these `UserInfoReadModel` objects should be created whenever a `UserCreated` event is seen. For that, we can just use a plain-old C# constructor:

```csharp
public class UserInfoReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public bool HasSetPassword { get; set; }

    public UserInfoReadModel(UserCreated userCreated)
    {
        
    }
}
```

We can tell the Critter Stack to go through all the events for this particular user, and create us a `UserInfoReadModel` object. 

```csharp del={"ðŸš«": 6} ins={"âœ…": 3,5}  del={"ðŸš«": 7}
    var readModel = await session.Events.AggregateStreamAsync<UserInfoReadModel>(userStreamId);
            
    Assert.NotNull(readModel);
            
    Assert.Equal(userStreamId, readModel.Id);
    Assert.Equal("paulo", readModel.Name);
    Assert.True(readModel.HasSetPassword);
```

:::note
The green âœ… indicates assertions that pass, and the red ðŸš« are failures.
:::

But already you can see this is pretty powerful. Notice I didn't even have to *do anything*, and it automatically set the `Id` property for me. I just had to tell it what to do when it saw a `UserCreated` event, and it did the rest for me.

We can use the constructor, like we've done here, to indicate that this should be an *aggregation* of all the events that come after this one (`UserCreated`).

We are saying, in effect, that this is the *first* event we care about, and we want to build a projection of all the events that come after it.

All the *other* events for this Id should just be *applied* this object.


```csharp ins={13-18}
public class UserInfoReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public bool HasSetPassword { get; set; }

    
    public UserInfoReadModel(UserCreated userCreated)
    {
       // This will set the "Id" for us automatically.
    }
    
    public void Apply(UserSetName e)
    {
        Name = e.UserName;
    }
    
    public void Apply(UserSetPassword _) => HasSetPassword = true;
}
```